##  クエリインターフェイス
- 概要
  - データベースに問い合わせる際の窓口のこと

##  DBからオブジェクトを取得する
- 単一のオブジェクトを取り出す
  - find
    - 主キーに対応するオブジェクトを取り出す
    - find_byと違い、なにもないときは「nill」を返す
      ```rb
      if User.find(1)
      # id:1のユーザがいる場合
      else
      # id:1のユーザいない場合
      end
      ```
  - take
    - レコードを１件取り出す
  - first
    - 主キー順の最初のレコードを取り出す
  - last
    - 主キー順の最後のレコードを取り出す
  - find_by
    - 条件に合致するレコードの中で最初の１件を取り出す
- （後で）複数のオブジェクトをバッチで取り出す


##  (後で)条件


##  並び替え
- DBから取り出すレコードを特定の順序で並び替える
  - order
    - Book.order(created_at: :desc)
    - ASC(昇順)やDESC(降順)も指定できる
    - 複数のフィールドを指定して並べることもできる

##  特定のフィールドだけを取り出す
- 結果セットから特定のフィールドだけを取り出す
  - select
    - Book.select(:isbn, :out_of_print)
- 重複のない一意の値を１レコードだけ取り出す
  - distinct
    - Book.select(:last_name).distinct

##  LimitとOffset
- 取り出すレコードの数を制限する
  - limit
    - 最初の５件を取り出す
    - Book.limit(5)
  - offset
    - 最初の30件をスキップして、31件から５件を取り出す
    - Book.limit(5).offset(30)

##  グループ
- レコードをグループ化する
  - group
    - 注文(order)の作成日のコレクションを検索したい
    - Order.select("created_at").group("created_at")
- グループ化された項目の数をカウントする
  - count
    - Order.group(:status).count

##  Having条件
- グループ化されたレコードに対して条件を指定する
  - having
    - priceが1000円以上の商品のみを取り出す
    - Order.select("created_at, sum(total) as total_price").
  group("created_at").having("sum(total) > ?", 1000)

##  条件を上書きする
- 特定の条件を取り除ける
  - unscope
    - Book.where('id > 100').order('id desc').unscope(:order)
- 条件を上書きする
  - only
    - Book.where('id > 100').order('id desc').only(:where)
- 既存のselect文を上書きする
  - reselect
    - Book.select(:isbn).reselect(:title)
- スコープの並び順を上書きする
  - reorder
    - Author.find(10).books.reorder('year_published ASC')
- 並び順を逆にする
  - reverse_order
    - Book.where("author_id > 10").reverse_order
- 既存のwhere条件を上書きする
  - rewhere
    - Book.where("author_id > 10").rewhere("author_id < 20")
- 既存の名前付きgroup条件をオーバーライドする
  - regroup
    - Book.group(:author_id).regroup("title")
##  (後で)Nullリレーション


##  読み取り専用オブジェクト
- 返されたどのオブジェクトにも変更を明示的に禁止する
  - 銀行レベルのセキュリティを必要とする場合に使用する（実際は使っていない）
  - readonly
    - visitsの値を更新して、customer.saveを行うと例外が発生する
    ```rb
    customer = Customer.readonly.first
    customer.visits += 1
    customer.save # ActiveRecord::ReadOnlyRecordがraiseされる
    ```

##  レコードを更新できないようロックする
- 排他制御とは
  - 他のユーザーが同時に更新できないようにすること
- 楽観ロック
  - めったなことでは他者との同時更新は起きないだろう
  - データ取得時のバージョンとデータ更新時のバーションが同じだと更新できる
- 楽観的ロックカラム
  - lock_version（integer型）
    - レコードが更新されるたびにカラムの値が１増える
    - lock_versionの値がDB上のlock_versionの値より小さい場合は失敗する
- 悲観ロック
  - 他者が同じデータを頻繁に更新する可能性があるだろう
  - データ取得時にロックをかけて他者の更新を待つ
- DBが提供するロック機能
  - リレーションの構築時にlockを使うと、選択した行にロックをかける
- トランザクションの概念
  - トランザクションとは
    - 一連の処理をまとめて、全て「成功」か「失敗」のどちらかにすること
    - 一連のデータ処理の途中で問題が起こったらそれまでの操作をすべてもとに戻しすことで、データの整合性を保つ
  - トランザクションの4つの特性
    - ACID
      - Atomicity（原子性）
        - 全て成功するか全て失敗するかのどちらか
        - 原子性：ある物事が、それ以上細かい単位に分割できないこと
      - Consistency（一貫性）
        - トランザクション前後のデータは同じ！
      - Isolation（独立性）
        - 同時に複数のトランザクションを実行しても互いに影響を与えない
      - Durability（永続性）
        - 完了後は、いくらハードウェアが壊れてもデータは消えない



##  (後で)テーブルを結合する

##  関連付けをeager loadingする
- eager loadingとは？
  - 「先にデータを取得しておく」こと
- N + 1クエリ問題
  - 合計で11回のクエリが発行される
    - 本を10冊検索するクエリを1回発行
    - そこからlast_nameを取り出すクエリを10回発行
- N + 1クエリ問題を解決する
  - includes
    - 関連するテーブルのレコードをまとめて取得することで必要以上のSQLを発行しない
    - モデル名.includes(:関連名)
- 複数の関連付けをeager loadingする
  - 複数の関連付けの配列
    - Customer.includes(:orders, :reviews)
      - 顧客とその顧客に関連付けられている注文とレビューを取得する
  - ネストした関連付けハッシュ
    - Customer.includes(orders: { books: [:supplier, :author] }).find(1)
      - id=1の顧客を検索し、関連付けられた全ての注文、それぞれの本の仕入先と著者を読み込む
- （後で）14.2.2 関連付けのeager loadingで条件を指定する
- （後で）preload
- eager_load
  - 指定されたすべての関連付けをLEFT OUTER JOINで読み込む
    - LEFT OUTER JOINとは？
      - 左側のテーブルのレコードを全て保持しつつ、右側のテーブルから一致するレコードを取得する
- strict_loading
    - 関連付けで発生する遅延読み込みを防ぐ
    - 有効にすると、遅延読み込みをしたときに例外が発生する
      - user = User.strict_loading.first
- strict_loading!
  - レコード自身でstrict_loadingを有効にする
    ```rb
    user = User.first
    user.strict_loading!
    ```



- 参考資料
  - https://qiita.com/NagaokaKenichi/items/73040df85b7bd4e9ecfc
  - https://pikawaka.com/rails/includes
